name: Deploy to AWS ECS

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: goalaroo-app
  ECS_CLUSTER: goalaroo-cluster
  ECS_SERVICE: goalaroo-service
  ECS_TASK_DEFINITION: goalaroo-task

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd backend
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Check if task definition exists
      id: check-task-def
      run: |
        if aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Download existing task definition
      if: steps.check-task-def.outputs.exists == 'true'
      run: |
        aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION }} \
        --region ${{ env.AWS_REGION }} --query taskDefinition > task-definition.json

    - name: Create new task definition
      if: steps.check-task-def.outputs.exists == 'false'
      run: |
        # Get AWS account ID
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        
        cat > task-definition.json << EOF
        {
          "family": "${{ env.ECS_TASK_DEFINITION }}",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${ACCOUNT_ID}:role/goalaroo-ecs-execution-role",
          "taskRoleArn": "arn:aws:iam::${ACCOUNT_ID}:role/goalaroo-ecs-task-role",
          "containerDefinitions": [
            {
              "name": "goalaroo-container",
              "image": "${{ steps.build-image.outputs.image }}",
              "essential": true,
              "portMappings": [
                {
                  "containerPort": 3000,
                  "protocol": "tcp"
                }
              ],
              "environment": [
                {
                  "name": "NODE_ENV",
                  "value": "production"
                },
                {
                  "name": "AWS_REGION",
                  "value": "${{ env.AWS_REGION }}"
                },
                {
                  "name": "FRONTEND_URL",
                  "value": "https://mcsoko.com"
                }
              ],
              "secrets": [
                {
                  "name": "JWT_SECRET",
                  "valueFrom": "arn:aws:ssm:${{ env.AWS_REGION }}:${ACCOUNT_ID}:parameter/goalaroo/jwt-secret"
                },
                {
                  "name": "FROM_EMAIL",
                  "valueFrom": "arn:aws:ssm:${{ env.AWS_REGION }}:${ACCOUNT_ID}:parameter/goalaroo/from-email"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/goalaroo",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF

    - name: Update task definition image
      if: steps.check-task-def.outputs.exists == 'true'
      run: |
        # Update the image in the task definition and clean up metadata fields
        jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy) | .containerDefinitions[0].image = "${{ steps.build-image.outputs.image }}"' task-definition.json > new-task-definition.json
        
        # Clean up additional problematic fields for FARGATE
        jq 'del(.containerDefinitions[0].portMappings[0].hostPort, .containerDefinitions[0].mountPoints, .containerDefinitions[0].volumesFrom, .containerDefinitions[0].systemControls, .volumes, .placementConstraints)' new-task-definition.json > cleaned-task-definition.json

    - name: Copy task definition for registration
      if: steps.check-task-def.outputs.exists == 'true'
      run: |
        cp cleaned-task-definition.json task-definition-to-register.json

    - name: Copy task definition for registration (new)
      if: steps.check-task-def.outputs.exists == 'false'
      run: |
        # Clean up any metadata fields that might be present
        jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy) // .' task-definition.json > task-definition-to-register.json

    - name: Debug task definition
      run: |
        echo "Task definition to register:"
        cat task-definition-to-register.json

    - name: Deploy to ECS
      run: |
        # Register the task definition
        aws ecs register-task-definition --cli-input-json file://task-definition-to-register.json --region ${{ env.AWS_REGION }}
        
        # Check if service exists
        if aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --region ${{ env.AWS_REGION }} --query 'services[0].status' --output text | grep -q "ACTIVE"; then
          # Update existing service
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ env.ECS_TASK_DEFINITION }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          # Wait for service to be stable
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }}
        else
          echo "Service does not exist yet. Please run Terraform first to create the infrastructure."
          exit 1
        fi

    - name: Update frontend API URL
      run: |
        # Get the API URL from Terraform output
        cd terraform
        API_URL=$(terraform output -raw api_url)
        cd ..
        
        # Update the API_BASE_URL in app.js
        sed -i "s|const API_BASE_URL = '.*'|const API_BASE_URL = '${API_URL}'|" app.js
        
        # Commit and push the updated frontend
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add app.js
        git commit -m "Update API URL after deployment" || echo "No changes to commit"
        git push

    - name: Deployment Status
      run: |
        echo "‚úÖ Deployment completed successfully!"
        echo "üöÄ API URL: $(cd terraform && terraform output -raw api_url)"
        echo "üê≥ ECR Repository: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}"
        echo "üì¶ Image Tag: ${{ github.sha }}" 